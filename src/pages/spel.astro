---
import Layout from '../layouts/Layout.astro';
---

<Layout title="High Steaks - Kotlett.se">
    <div class="container">
        <h1>High Steaks</h1>
        <p class="subtitle">V√§nd kotletterna i perfekt tid!</p>
        <h3 class="text-center">Ibland √§r spel inte r√§ttvisa</h3>
        <div class="game-wrapper">
            <div class="game-ui">
                <div class="ui-top">
                    <div class="ui-item">
                        <span class="ui-label">Po√§ng</span>
                        <span class="ui-value" id="score">0</span>
                    </div>
                    <div class="ui-item combo-display" id="combo-display">
                        <span class="ui-label">Combo</span>
                        <span class="ui-value combo-value" id="combo">0</span>
                    </div>
                    <div class="ui-item">
                        <span class="ui-label">Niv√•</span>
                        <span class="ui-value" id="level">1</span>
                    </div>
                    <div class="ui-item">
                        <span class="ui-label">Tid</span>
                        <span class="ui-value" id="timer">60</span>
                    </div>
                </div>
            </div>

            <div class="game-container">
                <canvas id="gameCanvas"></canvas>
                <div class="game-overlay hidden" id="gameOverlay">
                    <div class="overlay-content">
                        <h2 id="overlayTitle">High Steaks</h2>
                        <p id="overlayMessage">Tryck f√∂r att b√∂rja!</p>
                        <div class="final-stats hidden" id="finalStats">
                            <div class="stat-item">
                                <span class="stat-label">Slutpo√§ng:</span>
                                <span class="stat-value" id="finalScore">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">B√§sta combo:</span>
                                <span class="stat-value" id="bestCombo">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Perfekta v√§nd:</span>
                                <span class="stat-value" id="perfectFlips">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Kotletter klarade:</span>
                                <span class="stat-value" id="cutletsCompleted">0</span>
                            </div>
                        </div>
                        <div class="level-complete-stats hidden" id="levelCompleteStats">
                            <div class="stat-item">
                                <span class="stat-label">Niv√• klarad!</span>
                                <span class="stat-value" id="completedLevel">1</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Po√§ng denna niv√•:</span>
                                <span class="stat-value" id="levelScore">0</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Total po√§ng:</span>
                                <span class="stat-value" id="totalScore">0</span>
                            </div>
                        </div>
                        <button class="game-button" id="startButton">B√∂rja spela</button>
                        <button class="game-button secondary-button hidden" id="nextLevelButton">N√§sta niv√•</button>
                    </div>
                </div>
            </div>

            <div class="game-info">
                <div class="info-item">
                    <span class="info-label">Nuvarande streak:</span>
                    <span class="info-value" id="streak">0</span>
                </div>
                <div class="info-item">
                    <span class="info-label">High score:</span>
                    <span class="info-value" id="highScore">0</span>
                </div>
            </div>

            <div class="instructions">
                <h3>Hur man spelar</h3>
                <ul>
                    <li><strong>Tryck p√• kotletterna</strong> f√∂r att v√§nda dem i perfekt tid</li>
                    <li><strong>Perfekt stekyta</strong> = perfekt tillf√§lle att v√§nda!</li>
                    <li><strong>Combo-clicker</strong> f√∂r flera perfekta v√§nd i rad</li>
                    <li><strong>Br√§nda kotletter</strong> ger minuspo√§ng!</li>
                </ul>
            </div>
        </div>

        <div style="margin-top: 4rem;">
            <h1>Meat Matcher</h1>
        <p class="subtitle">Swipa dig fram till din perfekta kotlett!</p>
            <div class="game-wrapper-matcher">
                <div class="question-counter-matcher hidden" id="questionCounterMatcher">Fr√•ga 1 av 10</div>
                <div class="card-container" id="cardContainer">
                    <!-- Cards will be inserted here -->
                </div>

                <div class="start-screen" id="startScreenMatcher">
                    <div class="start-content">
                        <h2>V√§lkommen till Meat Matcher!</h2>
                        <p>Svara p√• 10 fr√•gor genom att swipa h√∂ger (JA) eller v√§nster (NEJ)</p>
                        <p>Vi kommer att matcha dig med din perfekta kotlett!</p>
                        <button class="start-button" id="startButtonMatcher">B√∂rja matcha</button>
                    </div>
                </div>

                <div class="result-screen hidden" id="resultScreenMatcher">
                    <div class="result-content">
                        <h2>Din perfekta match!</h2>
                        <div class="cutlet-result" id="cutletResult">
                            <!-- Result will be inserted here -->
                        </div>
                        <button class="restart-button" id="restartButtonMatcher">Matcha igen</button>
                    </div>
                </div>

                <div class="progress-bar-matcher" id="progressBarMatcher">
                    <div class="progress-fill" id="progressFillMatcher"></div>
                    <span class="progress-text" id="progressTextMatcher">0/10</span>
                </div>

                <div class="swipe-buttons" id="swipeButtonsMatcher">
                    <button class="swipe-btn swipe-left" id="swipeLeftBtnMatcher">
                        <span class="btn-icon">‚úï</span>
                        <span class="btn-text">NEJ</span>
                    </button>
                    <button class="swipe-btn swipe-right" id="swipeRightBtnMatcher">
                        <span class="btn-icon">‚ô•</span>
                        <span class="btn-text">JA</span>
                    </button>
                </div>
            </div>
        </div>
    </div>
</Layout>

<script>
    interface Cutlet {
        id: number;
        x: number;
        y: number;
        lane: number;
        type: 'thin' | 'thick' | 'bone-in';
        cookState: number; // 0-100 per side
        flipped: boolean;
        secondSide: boolean;
        speed: number;
        width: number;
        height: number;
        perfectWindowStart: number;
        perfectWindowEnd: number;
        perfectWindowStart2: number;
        perfectWindowEnd2: number;
    }

    interface Particle {
        x: number;
        y: number;
        vx: number;
        vy: number;
        life: number;
        maxLife: number;
        type: 'sizzle' | 'smoke' | 'sparkle';
        size: number;
    }

    class HighSteaksGame {
        private canvas: HTMLCanvasElement;
        private ctx: CanvasRenderingContext2D;
        private cutlets: Cutlet[] = [];
        private particles: Particle[] = [];
        private score: number = 0;
        private combo: number = 0;
        private bestCombo: number = 0;
        private streak: number = 0;
        private perfectFlips: number = 0;
        private level: number = 1;
        private cutletsFlippedInLevel: number = 0;
        private cutletsNeededForNextLevel: number = 10;
        private levelStartScore: number = 0;
        private canProgressToNextLevel: boolean = false;
        private timeLeft: number = 60;
        private gameRunning: boolean = false;
        private nextCutletId: number = 0;
        private lanes: number = 4;
        private laneHeight: number = 0;
        private grillTop: number = 0;
        private lastSpawnTime: number = 0;
        private spawnInterval: number = 2000;
        private animationFrame: number = 0;
        private lastTime: number = 0;
        private timerInterval: number = 0;
        private highScore: number = 0;

        // Canvas dimensions
        private canvasWidth: number = 800;
        private canvasHeight: number = 500;

        constructor(canvas: HTMLCanvasElement) {
            this.canvas = canvas;
            const context = canvas.getContext('2d');
            if (!context) throw new Error('Could not get canvas context');
            this.ctx = context;

            this.setupCanvas();
            this.loadHighScore();
            this.bindEvents();
            this.showStartScreen();
        }

        private setupCanvas(): void {
            const container = this.canvas.parentElement;
            if (!container) return;

            const containerWidth = container.clientWidth;
            const scale = Math.min(containerWidth / this.canvasWidth, 1);

            this.canvas.width = this.canvasWidth;
            this.canvas.height = this.canvasHeight;
            this.canvas.style.width = `${this.canvasWidth * scale}px`;
            this.canvas.style.height = `${this.canvasHeight * scale}px`;

            this.laneHeight = (this.canvasHeight - this.grillTop - 40) / this.lanes;
        }

        private bindEvents(): void {
            this.canvas.addEventListener('click', (e) => this.handleClick(e));
            this.canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.handleTouch(e);
            }, { passive: false });

            const startButton = document.getElementById('startButton');
            if (startButton) {
                startButton.addEventListener('click', () => this.startGame());
            }

            const nextLevelButton = document.getElementById('nextLevelButton');
            if (nextLevelButton) {
                nextLevelButton.addEventListener('click', () => this.continueToNextLevel());
            }

            window.addEventListener('resize', () => this.setupCanvas());
        }

        private handleClick(e: MouseEvent): void {
            if (!this.gameRunning) return;

            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            this.checkCutletClick(x, y);
        }

        private handleTouch(e: TouchEvent): void {
            if (!this.gameRunning) return;

            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            const touch = e.touches[0];
            const x = (touch.clientX - rect.left) * scaleX;
            const y = (touch.clientY - rect.top) * scaleY;

            this.checkCutletClick(x, y);
        }

        private checkCutletClick(x: number, y: number): void {
            for (let i = this.cutlets.length - 1; i >= 0; i--) {
                const cutlet = this.cutlets[i];

                if (x >= cutlet.x && x <= cutlet.x + cutlet.width &&
                    y >= cutlet.y && y <= cutlet.y + cutlet.height) {
                    const shouldRemove = this.flipCutlet(cutlet);
                    if (shouldRemove) {
                        this.cutlets.splice(i, 1);
                    }
                    break;
                }
            }
        }

        private flipCutlet(cutlet: Cutlet): boolean {
            if (!cutlet.secondSide && !cutlet.flipped) {
                // First flip
                const cookState = cutlet.cookState;
                const isPerfect = cookState >= cutlet.perfectWindowStart &&
                                 cookState <= cutlet.perfectWindowEnd;

                if (isPerfect) {
                    this.score += 100 * (1 + this.combo * 0.5);
                    this.combo++;
                    this.streak++;
                    this.perfectFlips++;
                    this.createSparkles(cutlet.x + cutlet.width / 2, cutlet.y + cutlet.height / 2);
                } else if (cookState > cutlet.perfectWindowEnd) {
                    // Burnt
                    this.score = Math.max(0, this.score - 50);
                    this.combo = 0;
                    this.streak = 0;
                } else {
                    // Too early
                    this.score += 25;
                    this.combo = 0;
                    this.streak = 0;
                }

                // Transition to second side
                cutlet.secondSide = true;
                cutlet.flipped = false;
                cutlet.cookState = 0;

                this.bestCombo = Math.max(this.bestCombo, this.combo);
                this.updateUI();
                return false; // Don't remove, continue cooking second side

            } else if (cutlet.secondSide && !cutlet.flipped) {
                // Second flip - cutlet is now complete!
                const cookState = cutlet.cookState;
                const isPerfect = cookState >= cutlet.perfectWindowStart2 &&
                                 cookState <= cutlet.perfectWindowEnd2;

                if (isPerfect) {
                    this.score += 150 * (1 + this.combo * 0.5);
                    this.combo++;
                    this.streak++;
                    this.perfectFlips++;
                    this.createSparkles(cutlet.x + cutlet.width / 2, cutlet.y + cutlet.height / 2);
                } else if (cookState > cutlet.perfectWindowEnd2) {
                    // Burnt
                    this.score = Math.max(0, this.score - 100);
                    this.combo = 0;
                    this.streak = 0;
                } else {
                    // Too early
                    this.score += 50;
                    this.combo = 0;
                    this.streak = 0;
                }

                // Count this as a completed cutlet
                this.cutletsFlippedInLevel++;
                console.log(`Completed cutlet! Total: ${this.cutletsFlippedInLevel}/${this.cutletsNeededForNextLevel}`);

                if (this.cutletsFlippedInLevel >= this.cutletsNeededForNextLevel) {
                    this.canProgressToNextLevel = true;
                    console.log('Level requirement met!');
                }

                this.bestCombo = Math.max(this.bestCombo, this.combo);
                this.updateUI();
                return true; // Remove cutlet from board
            }

            this.bestCombo = Math.max(this.bestCombo, this.combo);
            this.updateUI();
            return false;
        }

        private showLevelUpNotification(): void {
            // Create sparkle particles at random positions
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * this.canvasWidth;
                const y = Math.random() * this.canvasHeight;
                this.createSparkles(x, y);
            }
        }

        private spawnCutlet(): void {
            const lane = Math.floor(Math.random() * this.lanes);
            const types: ('thin' | 'thick' | 'bone-in')[] = ['thin', 'thick', 'bone-in'];
            const type = types[Math.floor(Math.random() * types.length)];

            // Level multiplier: increases speed and cook rate
            const levelMultiplier = 1 + (this.level - 1) * 0.1;

            let speed = 0.5 * levelMultiplier;
            let perfectWindow1 = [35, 45];
            let perfectWindow2 = [40, 50];

            // Adjust perfect windows for higher levels (faster cooking = tighter windows)
            const windowAdjustment = Math.max(0, (this.level - 1) * 2);

            switch (type) {
                case 'thin':
                    speed = 0.7 * levelMultiplier;
                    perfectWindow1 = [Math.max(25, 30 - windowAdjustment), Math.max(35, 40 - windowAdjustment)];
                    perfectWindow2 = [Math.max(30, 35 - windowAdjustment), Math.max(40, 45 - windowAdjustment)];
                    break;
                case 'thick':
                    speed = 0.4 * levelMultiplier;
                    perfectWindow1 = [Math.max(35, 45 - windowAdjustment), Math.max(45, 55 - windowAdjustment)];
                    perfectWindow2 = [Math.max(40, 50 - windowAdjustment), Math.max(50, 60 - windowAdjustment)];
                    break;
                case 'bone-in':
                    speed = 0.55 * levelMultiplier;
                    perfectWindow1 = [Math.max(30, 40 - windowAdjustment), Math.max(40, 50 - windowAdjustment)];
                    perfectWindow2 = [Math.max(35, 45 - windowAdjustment), Math.max(45, 55 - windowAdjustment)];
                    break;
            }

            const cutlet: Cutlet = {
                id: this.nextCutletId++,
                x: 0,
                y: this.grillTop + lane * this.laneHeight + this.laneHeight / 2 - 25,
                lane,
                type,
                cookState: 0,
                flipped: false,
                secondSide: false,
                speed,
                width: type === 'bone-in' ? 70 : 60,
                height: 50,
                perfectWindowStart: perfectWindow1[0],
                perfectWindowEnd: perfectWindow1[1],
                perfectWindowStart2: perfectWindow2[0],
                perfectWindowEnd2: perfectWindow2[1]
            };

            this.cutlets.push(cutlet);
        }

        private createSizzle(x: number, y: number): void {
            for (let i = 0; i < 2; i++) {
                this.particles.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y + (Math.random() - 0.5) * 30,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: -0.5 - Math.random() * 0.5,
                    life: 30,
                    maxLife: 30,
                    type: 'sizzle',
                    size: 3 + Math.random() * 3
                });
            }
        }

        private createSmoke(x: number, y: number): void {
            for (let i = 0; i < 3; i++) {
                this.particles.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y + (Math.random() - 0.5) * 30,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: -1 - Math.random() * 0.5,
                    life: 40,
                    maxLife: 40,
                    type: 'smoke',
                    size: 5 + Math.random() * 5
                });
            }
        }

        private createSparkles(x: number, y: number): void {
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 * i) / 8;
                this.particles.push({
                    x,
                    y,
                    vx: Math.cos(angle) * 2,
                    vy: Math.sin(angle) * 2,
                    life: 20,
                    maxLife: 20,
                    type: 'sparkle',
                    size: 4
                });
            }
        }

        private update(deltaTime: number): void {
            // Spawn cutlets
            if (Date.now() - this.lastSpawnTime > this.spawnInterval) {
                this.spawnCutlet();
                this.lastSpawnTime = Date.now();

                // Gradually increase difficulty
                if (this.spawnInterval > 1000) {
                    this.spawnInterval -= 10;
                }
            }

            // Update cutlets
            const cookRateMultiplier = 1 + (this.level - 1) * 0.1;
            for (let i = this.cutlets.length - 1; i >= 0; i--) {
                const cutlet = this.cutlets[i];
                cutlet.x += cutlet.speed * (deltaTime / 16);

                // Cook when not flipped
                if (!cutlet.flipped) {
                    cutlet.cookState += cutlet.speed * 0.15 * cookRateMultiplier * (deltaTime / 16);
                }

                // Create particles
                if (cutlet.cookState > 60 && !cutlet.flipped) {
                    if (Math.random() < 0.1) {
                        this.createSmoke(cutlet.x + cutlet.width / 2, cutlet.y + cutlet.height / 2);
                    }
                } else if (cutlet.cookState > 20 && !cutlet.flipped) {
                    if (Math.random() < 0.05) {
                        this.createSizzle(cutlet.x + cutlet.width / 2, cutlet.y + cutlet.height / 2);
                    }
                }

                // Remove if off screen or burnt
                if (cutlet.x > this.canvasWidth || cutlet.cookState > 100) {
                    if (cutlet.cookState > 100) {
                        // Burnt - penalty
                        this.score = Math.max(0, this.score - 100);
                        this.combo = 0;
                        this.streak = 0;
                        console.log('Cutlet burnt!');
                    }
                    // Just remove the cutlet (completed ones are already counted when flipped)
                    this.cutlets.splice(i, 1);
                }
            }

            // Update particles
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const particle = this.particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;

                if (particle.life <= 0) {
                    this.particles.splice(i, 1);
                }
            }

            this.updateUI();
        }

        private draw(): void {
            // Clear canvas
            this.ctx.fillStyle = '#f5f1e8';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // Draw grill background
            this.ctx.fillStyle = '#3a3a3a';
            this.ctx.fillRect(0, this.grillTop, this.canvas.width, this.canvas.height - this.grillTop);

            // Draw grill lines
            this.ctx.strokeStyle = '#555';
            this.ctx.lineWidth = 3;
            for (let i = 0; i <= this.lanes; i++) {
                const y = this.grillTop + i * this.laneHeight;
                this.ctx.beginPath();
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(this.canvas.width, y);
                this.ctx.stroke();
            }

            // Draw vertical grill lines
            for (let i = 0; i < 20; i++) {
                const x = (this.canvas.width / 20) * i;
                this.ctx.beginPath();
                this.ctx.moveTo(x, this.grillTop);
                this.ctx.lineTo(x, this.canvas.height);
                this.ctx.stroke();
            }

            // Draw particles
            for (const particle of this.particles) {
                const alpha = particle.life / particle.maxLife;

                if (particle.type === 'sizzle') {
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                } else if (particle.type === 'smoke') {
                    this.ctx.fillStyle = `rgba(80, 80, 80, ${alpha * 0.4})`;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                } else if (particle.type === 'sparkle') {
                    this.ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            // Draw cutlets
            for (const cutlet of this.cutlets) {
                const cookState = cutlet.cookState;
                let color = '#ffb3ba'; // Raw pink

                if (!cutlet.secondSide) {
                    // First side
                    if (cookState >= cutlet.perfectWindowStart && cookState <= cutlet.perfectWindowEnd) {
                        color = '#d4a574'; // Perfect golden
                    } else if (cookState > cutlet.perfectWindowEnd && cookState <= 70) {
                        color = '#b8935e'; // Getting darker
                    } else if (cookState > 70) {
                        color = '#4a3520'; // Burnt
                    } else if (cookState > 20) {
                        color = '#f5d0a9'; // Cooking
                    }
                } else {
                    // Second side
                    if (cookState >= cutlet.perfectWindowStart2 && cookState <= cutlet.perfectWindowEnd2) {
                        color = '#d4a574'; // Perfect golden
                    } else if (cookState > cutlet.perfectWindowEnd2 && cookState <= 70) {
                        color = '#b8935e'; // Getting darker
                    } else if (cookState > 70) {
                        color = '#4a3520'; // Burnt
                    } else if (cookState > 20) {
                        color = '#f5d0a9'; // Cooking
                    }
                }

                // Draw cutlet shadow
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.fillRect(cutlet.x + 2, cutlet.y + 2, cutlet.width, cutlet.height);

                // Draw cutlet
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.roundRect(cutlet.x, cutlet.y, cutlet.width, cutlet.height, 8);
                this.ctx.fill();

                // Draw bone for bone-in cutlet
                if (cutlet.type === 'bone-in') {
                    this.ctx.fillStyle = '#f5f5dc';
                    this.ctx.fillRect(cutlet.x + cutlet.width - 15, cutlet.y + 5, 8, cutlet.height - 10);
                }

                // Draw grill marks
                this.ctx.strokeStyle = 'rgba(139, 69, 19, 0.6)';
                this.ctx.lineWidth = 2;
                for (let i = 0; i < 3; i++) {
                    const markY = cutlet.y + (cutlet.height / 4) * (i + 1);
                    this.ctx.beginPath();
                    this.ctx.moveTo(cutlet.x + 5, markY);
                    this.ctx.lineTo(cutlet.x + cutlet.width - 5, markY);
                    this.ctx.stroke();
                }

                // Draw perfect window glow
                const isPerfect = (!cutlet.secondSide &&
                                  cookState >= cutlet.perfectWindowStart &&
                                  cookState <= cutlet.perfectWindowEnd) ||
                                 (cutlet.secondSide &&
                                  cookState >= cutlet.perfectWindowStart2 &&
                                  cookState <= cutlet.perfectWindowEnd2);

                if (isPerfect && !cutlet.flipped) {
                    const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
                    this.ctx.strokeStyle = `rgba(255, 215, 0, ${pulse})`;
                    this.ctx.lineWidth = 4;
                    this.ctx.beginPath();
                    this.ctx.roundRect(cutlet.x - 5, cutlet.y - 5, cutlet.width + 10, cutlet.height + 10, 12);
                    this.ctx.stroke();

                    // Inner glow
                    this.ctx.strokeStyle = `rgba(255, 255, 255, ${pulse * 0.5})`;
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }

                // Draw flip indicator
                if (cutlet.secondSide) {
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = 'bold 12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('2', cutlet.x + cutlet.width / 2, cutlet.y - 5);
                }
            }
        }

        private gameLoop(currentTime: number): void {
            if (!this.gameRunning) return;

            const deltaTime = currentTime - this.lastTime;
            this.lastTime = currentTime;

            this.update(deltaTime);
            this.draw();

            this.animationFrame = requestAnimationFrame((time) => this.gameLoop(time));
        }

        private updateUI(): void {
            const scoreEl = document.getElementById('score');
            const comboEl = document.getElementById('combo');
            const comboDisplay = document.getElementById('combo-display');
            const streakEl = document.getElementById('streak');
            const levelEl = document.getElementById('level');

            if (scoreEl) scoreEl.textContent = Math.floor(this.score).toString();
            if (comboEl) comboEl.textContent = `x${this.combo}`;
            if (streakEl) streakEl.textContent = this.streak.toString();
            if (levelEl) levelEl.textContent = this.level.toString();

            if (comboDisplay) {
                if (this.combo > 0) {
                    comboDisplay.classList.add('active');
                } else {
                    comboDisplay.classList.remove('active');
                }
            }
        }

        private startTimer(): void {
            this.timerInterval = window.setInterval(() => {
                this.timeLeft--;
                const timerEl = document.getElementById('timer');
                if (timerEl) timerEl.textContent = this.timeLeft.toString();

                if (this.timeLeft <= 0) {
                    this.endGame();
                }
            }, 1000);
        }

        public startGame(): void {
            this.score = 0;
            this.combo = 0;
            this.bestCombo = 0;
            this.streak = 0;
            this.perfectFlips = 0;
            this.level = 1;
            this.cutletsFlippedInLevel = 0;
            this.cutletsNeededForNextLevel = 10;
            this.levelStartScore = 0;
            this.canProgressToNextLevel = false;
            this.timeLeft = 60;
            this.cutlets = [];
            this.particles = [];
            this.spawnInterval = 2000;
            this.lastSpawnTime = Date.now();
            this.gameRunning = true;

            const overlay = document.getElementById('gameOverlay');
            if (overlay) overlay.classList.add('hidden');

            this.updateUI();
            this.startTimer();
            this.lastTime = performance.now();
            this.gameLoop(this.lastTime);
        }

        private endGame(): void {
            this.gameRunning = false;
            clearInterval(this.timerInterval);
            cancelAnimationFrame(this.animationFrame);

            if (this.score > this.highScore) {
                this.highScore = this.score;
                this.saveHighScore();
            }

            const highScoreEl = document.getElementById('highScore');
            if (highScoreEl) highScoreEl.textContent = Math.floor(this.highScore).toString();

            // Check if player completed the level requirement
            if (this.canProgressToNextLevel) {
                this.showLevelComplete();
            } else {
                this.showGameOver();
            }
        }

        public continueToNextLevel(): void {
            // If canProgressToNextLevel is true, advance to next level
            // Otherwise, retry the same level
            if (this.canProgressToNextLevel) {
                this.level++;
                this.levelStartScore = this.score;
                this.cutletsNeededForNextLevel = 10 + (this.level - 1) * 2;
                this.showLevelUpNotification();
            }

            this.cutletsFlippedInLevel = 0;
            this.canProgressToNextLevel = false;

            // Reset time
            this.timeLeft = 60;
            this.cutlets = [];
            this.particles = [];
            this.combo = 0;
            this.streak = 0;
            this.spawnInterval = 2000;
            this.lastSpawnTime = Date.now();
            this.gameRunning = true;

            const overlay = document.getElementById('gameOverlay');
            if (overlay) overlay.classList.add('hidden');

            this.updateUI();
            this.startTimer();
            this.lastTime = performance.now();
            this.gameLoop(this.lastTime);
        }

        private showStartScreen(): void {
            const overlay = document.getElementById('gameOverlay');
            const title = document.getElementById('overlayTitle');
            const message = document.getElementById('overlayMessage');
            const button = document.getElementById('startButton');
            const nextButton = document.getElementById('nextLevelButton');
            const stats = document.getElementById('finalStats');
            const levelStats = document.getElementById('levelCompleteStats');

            if (overlay) overlay.classList.remove('hidden');
            if (title) title.textContent = 'High Steaks';
            if (message) message.textContent = 'V√§nd kotletterna i perfekt tid!';
            if (button) {
                button.textContent = 'B√∂rja spela';
                button.classList.remove('hidden');
            }
            if (nextButton) nextButton.classList.add('hidden');
            if (stats) stats.classList.add('hidden');
            if (levelStats) levelStats.classList.add('hidden');
        }

        private showLevelComplete(): void {
            const overlay = document.getElementById('gameOverlay');
            const title = document.getElementById('overlayTitle');
            const message = document.getElementById('overlayMessage');
            const button = document.getElementById('startButton');
            const nextButton = document.getElementById('nextLevelButton');
            const stats = document.getElementById('finalStats');
            const levelStats = document.getElementById('levelCompleteStats');
            const completedLevel = document.getElementById('completedLevel');
            const levelScore = document.getElementById('levelScore');
            const totalScore = document.getElementById('totalScore');

            if (overlay) overlay.classList.remove('hidden');
            if (title) title.textContent = 'Niv√• klar!';
            if (message) message.textContent = `Du klarade niv√• ${this.level}! Forts√§tt till n√§sta niv√• f√∂r √∂kad sv√•righet!`;
            if (button) button.classList.add('hidden');
            if (nextButton) {
                nextButton.classList.remove('hidden');
                nextButton.textContent = `Forts√§tt till niv√• ${this.level + 1}`;
            }
            if (stats) stats.classList.add('hidden');
            if (levelStats) levelStats.classList.remove('hidden');
            if (completedLevel) completedLevel.textContent = this.level.toString();
            if (levelScore) levelScore.textContent = Math.floor(this.score - this.levelStartScore).toString();
            if (totalScore) totalScore.textContent = Math.floor(this.score).toString();
        }

        private showGameOver(): void {
            const overlay = document.getElementById('gameOverlay');
            const title = document.getElementById('overlayTitle');
            const message = document.getElementById('overlayMessage');
            const button = document.getElementById('startButton');
            const nextButton = document.getElementById('nextLevelButton');
            const stats = document.getElementById('finalStats');
            const levelStats = document.getElementById('levelCompleteStats');
            const finalScore = document.getElementById('finalScore');
            const bestCombo = document.getElementById('bestCombo');
            const perfectFlips = document.getElementById('perfectFlips');
            const cutletsCompleted = document.getElementById('cutletsCompleted');

            if (overlay) overlay.classList.remove('hidden');
            if (title) title.textContent = 'Tid slut!';
            if (message) {
                message.textContent = `${this.getEndMessage()} Du klarade ${this.cutletsFlippedInLevel}/${this.cutletsNeededForNextLevel} kotletter!`;
            }
            if (button) {
                button.textContent = 'Starta om';
                button.classList.remove('hidden');
            }

            // Show next level button if they didn't complete enough cutlets but still want to try again
            if (nextButton) {
                nextButton.classList.remove('hidden');
                nextButton.textContent = 'F√∂rs√∂k igen';
            }

            if (stats) stats.classList.remove('hidden');
            if (levelStats) levelStats.classList.add('hidden');
            if (finalScore) finalScore.textContent = Math.floor(this.score).toString();
            if (bestCombo) bestCombo.textContent = `x${this.bestCombo}`;
            if (perfectFlips) perfectFlips.textContent = this.perfectFlips.toString();
            if (cutletsCompleted) cutletsCompleted.textContent = `${this.cutletsFlippedInLevel}/${this.cutletsNeededForNextLevel}`;
        }

        private getEndMessage(): string {
            if (this.score >= 5000) {
                return 'üèÜ Fantastiskt! Du √§r en grillm√§stare!';
            } else if (this.score >= 3000) {
                return 'ü•á Utm√§rkt grillning!';
            } else if (this.score >= 2000) {
                return 'ü•à Bra jobbat p√• grillen!';
            } else if (this.score >= 1000) {
                return 'ü•â Hyfsat, forts√§tt tr√§na!';
            } else {
                return 'üìö Forts√§tt tr√§na - timing √§r allt!';
            }
        }

        private saveHighScore(): void {
            try {
                localStorage.setItem('highSteaksHighScore', this.highScore.toString());
            } catch (e) {
                // localStorage not available
            }
        }

        private loadHighScore(): void {
            try {
                const saved = localStorage.getItem('highSteaksHighScore');
                if (saved) {
                    this.highScore = parseInt(saved, 10);
                    const highScoreEl = document.getElementById('highScore');
                    if (highScoreEl) highScoreEl.textContent = Math.floor(this.highScore).toString();
                }
            } catch (e) {
                // localStorage not available
            }
        }
    }

    // Initialize game when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;
        if (canvas) {
            new HighSteaksGame(canvas);
        }
    });

    // Meat Matcher Game
    interface Question {
        id: number;
        text: string;
        emoji: string;
        yesPoints: Record<string, number>;
        noPoints: Record<string, number>;
    }

    interface CutletResult {
        name: string;
        description: string;
        emoji: string;
        characteristics: string[];
        recipe?: string;
    }

    const allQuestions: Question[] = [
        {
            id: 1,
            text: "Gillar du smaker fr√•n Medelhavet?",
            emoji: "üåä",
            yesPoints: { greek: 3, mediterranean: 3, french: 2 },
            noPoints: { classic: 2, asian: 2 }
        },
        {
            id: 2,
            text: "F√∂redrar du krispiga, panerade kotletter?",
            emoji: "‚ú®",
            yesPoints: { schnitzel: 3, italian: 2, crispy: 3 },
            noPoints: { grilled: 2, smoked: 2 }
        },
        {
            id: 3,
            text: "√Ñr du sugen p√• n√•got exotiskt och asiatiskt?",
            emoji: "ü•¢",
            yesPoints: { asian: 3, teriyaki: 3 },
            noPoints: { classic: 2, mediterranean: 1 }
        },
        {
            id: 4,
            text: "√Ñlskar du stark, kryddig mat?",
            emoji: "üå∂Ô∏è",
            yesPoints: { spicy: 3, asian: 2, mexican: 2 },
            noPoints: { classic: 2, french: 2 }
        },
        {
            id: 5,
            text: "F√∂redrar du enklare, klassiska smaker?",
            emoji: "üë®‚Äçüç≥",
            yesPoints: { classic: 3, grilled: 2 },
            noPoints: { teriyaki: 2, mexican: 1 }
        },
        {
            id: 6,
            text: "Gillar du citrus och fr√§scha smaker?",
            emoji: "üçã",
            yesPoints: { mediterranean: 2, greek: 3, mexican: 2 },
            noPoints: { smoked: 2, classic: 1 }
        },
        {
            id: 7,
            text: "√Ñr ost ett m√•ste i din mat?",
            emoji: "üßÄ",
            yesPoints: { italian: 3, french: 3, schnitzel: 2 },
            noPoints: { asian: 2, greek: 1 }
        },
        {
            id: 8,
            text: "F√∂redrar du marinerade kotletter framf√∂r panerade?",
            emoji: "üçñ",
            yesPoints: { grilled: 3, greek: 2, teriyaki: 3 },
            noPoints: { schnitzel: 2, italian: 2 }
        },
        {
            id: 9,
            text: "Gillar du rostade, karamelliserade smaker?",
            emoji: "üî•",
            yesPoints: { grilled: 3, teriyaki: 2, smoked: 2 },
            noPoints: { schnitzel: 1 }
        },
        {
            id: 10,
            text: "F√∂redrar du traditionella recept framf√∂r moderna?",
            emoji: "üìñ",
            yesPoints: { classic: 3, french: 2, schnitzel: 2 },
            noPoints: { mexican: 2, spicy: 2 }
        },
        {
            id: 11,
            text: "Tycker du r√∂kig smak g√∂r maten b√§ttre?",
            emoji: "üí®",
            yesPoints: { smoked: 3, grilled: 2 },
            noPoints: { french: 2, italian: 1 }
        },
        {
            id: 12,
            text: "Gillar du s√∂ta och salta kombinationer?",
            emoji: "üçØ",
            yesPoints: { teriyaki: 3, asian: 2, honeygarlic: 3 },
            noPoints: { classic: 2, mediterranean: 1 }
        },
        {
            id: 13,
            text: "F√∂redrar du mat med mycket vitl√∂k?",
            emoji: "üßÑ",
            yesPoints: { greek: 3, mediterranean: 2, honeygarlic: 2 },
            noPoints: { classic: 2, teriyaki: 1 }
        },
        {
            id: 14,
            text: "√Ñr du sugen p√• n√•got med taco-vibes?",
            emoji: "üåÆ",
            yesPoints: { mexican: 3, spicy: 2 },
            noPoints: { french: 2, italian: 2 }
        },
        {
            id: 15,
            text: "Gillar du mat med rika, kr√§miga s√•ser?",
            emoji: "ü•õ",
            yesPoints: { french: 3, classic: 2 },
            noPoints: { grilled: 2, asian: 1 }
        },
        {
            id: 16,
            text: "F√∂redrar du k√∂tt som sm√§lter i munnen?",
            emoji: "üí´",
            yesPoints: { smoked: 3, french: 2, grilled: 2 },
            noPoints: { schnitzel: 1 }
        },
        {
            id: 17,
            text: "√Ñr du sugen p√• n√•got med honung?",
            emoji: "üçØ",
            yesPoints: { honeygarlic: 3, teriyaki: 2 },
            noPoints: { spicy: 2, schnitzel: 1 }
        },
        {
            id: 18,
            text: "Tycker du √∂rter g√∂r maten b√§ttre?",
            emoji: "üåø",
            yesPoints: { mediterranean: 3, greek: 2, french: 2 },
            noPoints: { asian: 1, mexican: 1 }
        },
        {
            id: 19,
            text: "F√∂redrar du mat med koriander och lime?",
            emoji: "üåø",
            yesPoints: { mexican: 3, spicy: 2, asian: 1 },
            noPoints: { classic: 2, french: 2 }
        },
        {
            id: 20,
            text: "Gillar du umami-rika smaker?",
            emoji: "üçÑ",
            yesPoints: { teriyaki: 3, asian: 3, smoked: 2 },
            noPoints: { classic: 1, mediterranean: 1 }
        }
    ];

    let questions: Question[] = [];

    const cutletResults: Record<string, CutletResult> = {
        greek: {
            name: "Grekiska Lammkotletter",
            description: "Med citron, vitl√∂k och oregano - en medelhavsdr√∂m!",
            emoji: "üá¨üá∑",
            characteristics: [
                "Marinerad i olivolja och citron",
                "Kryddad med oregano och vitl√∂k",
                "Serveras med tzatziki",
                "Perfekt f√∂r sommargrillen"
            ],
            recipe: "/recept/grekiska-lammkotletter"
        },
        italian: {
            name: "Veal Parmigiana",
            description: "Krispiga, ostiga och helt oemotst√•ndliga!",
            emoji: "üáÆüáπ",
            characteristics: [
                "Panerade med parmesan",
                "Krispigt skal med saftigt k√∂tt",
                "Perfekt med pasta eller sallad",
                "Smak av Italien"
            ],
            recipe: "/recept/veal-parmigiana"
        },
        schnitzel: {
            name: "Wiener Schnitzel",
            description: "Den klassiska √∂sterrikiska favoriten!",
            emoji: "ü•á",
            characteristics: [
                "Tunnklappad och panerad",
                "Gyllene och krispy",
                "Serveras med citronsklyftor",
                "Traditionell och √§lskad"
            ],
            recipe: "/recept/wiener-schnitzel"
        },
        classic: {
            name: "Klassisk Stekt Fl√§skkotlett",
            description: "Enkelt, gott och tidl√∂st!",
            emoji: "üá∏üá™",
            characteristics: [
                "Salt, peppar och sm√∂r",
                "Stekta till perfektion",
                "Serveras med gr√§dds√•s",
                "Svenskt husmanskost"
            ],
            recipe: "/recept/klassisk-stekt-flaskkotlett"
        },
        asian: {
            name: "Tonkatsu",
            description: "Japansk friterad fl√§skkotlett med krispig panko!",
            emoji: "ü•¢",
            characteristics: [
                "Panerad med panko",
                "Friterad till perfektion",
                "Serveras med tonkatsus√•s",
                "Japansk favorit"
            ],
            recipe: "/recept/tonkatsu"
        },
        spicy: {
            name: "Mexikanska Kotletter",
            description: "F√∂r dig som gillar det hett och smakrikt!",
            emoji: "üå∂Ô∏è",
            characteristics: [
                "Marinerad med chili och lime",
                "Stark och fr√§sch samtidigt",
                "Perfekt balans av hetta",
                "Moderna smaker"
            ],
            recipe: "/recept/milanesa-argentina"
        },
        grilled: {
            name: "Grillad Lammkotlett med Vitl√∂k",
            description: "Rostade till perfektion med r√∂kig smak!",
            emoji: "üî•",
            characteristics: [
                "Grillad √∂ver √∂ppen eld",
                "R√∂kig och karamelliserad yta",
                "Perfekt till sommaren",
                "Klassisk grillmat"
            ],
            recipe: "/recept/grillad-lammkotlett-med-vitlok"
        },
        mediterranean: {
            name: "Lammkotlett med Rosmarin",
            description: "Solkyssta smaker fr√•n Medelhavet!",
            emoji: "‚òÄÔ∏è",
            characteristics: [
                "Olivolja, timjan och rosmarin",
                "L√§tta och fr√§scha smaker",
                "Serveras med gr√∂nsaker",
                "H√§lsosamt och gott"
            ],
            recipe: "/recept/lammkotlett-med-rosmarin"
        },
        teriyaki: {
            name: "Tonkatsu",
            description: "S√∂t, salt och umami - japansk perfektion!",
            emoji: "üç±",
            characteristics: [
                "Glaserad med teriyakis√•s",
                "S√∂t och salt balans",
                "Serveras med sesamfr√∂n",
                "Asiatisk favorit"
            ],
            recipe: "/recept/tonkatsu"
        },
        mexican: {
            name: "Milanesa Argentina",
            description: "Kryddig, fr√§sch och full av liv!",
            emoji: "üåÆ",
            characteristics: [
                "Kryddad med cumin och koriander",
                "Serveras med lime och salsa",
                "Perfekt i tacos",
                "Festlig och smakrik"
            ],
            recipe: "/recept/milanesa-argentina"
        },
        french: {
            name: "Fl√§skkotlett med Dragon",
            description: "Elegant med senap, gr√§dde och dragon - ooh la la!",
            emoji: "üá´üá∑",
            characteristics: [
                "Tillagad med dijonsenap",
                "Kr√§mig dragons√•s",
                "Raffinerad smak",
                "Klassisk fransk mat"
            ],
            recipe: "/recept/flaskkotlett-med-dragon"
        },
        smoked: {
            name: "Italienska L√•ngkokta Kotletter",
            description: "L√•ngsamt kokta f√∂r maximal sm√∂righet!",
            emoji: "üí®",
            characteristics: [
                "Kokta i flera timmar",
                "Sm√§lter i munnen",
                "Djup rik smak",
                "Italiensk tradition"
            ],
            recipe: "/recept/italienska-langkokta-kotletter"
        },
        honeygarlic: {
            name: "Fl√§skkotlett med √Ñpple",
            description: "Perfekt balans mellan s√∂tt och smakrikt!",
            emoji: "üçØ",
            characteristics: [
                "Serveras med stekta √§pplen",
                "S√∂t och salt kombination",
                "Karamelliserad yta",
                "Familjefavorit"
            ],
            recipe: "/recept/flaskkotlett-med-apple"
        }
    };

    class MeatMatchGame {
        private currentQuestion: number = 0;
        private answers: boolean[] = [];
        private scores: Record<string, number> = {};
        private startX: number = 0;
        private currentX: number = 0;
        private isDragging: boolean = false;
        private currentCard: HTMLElement | null = null;

        constructor() {
            this.initializeScores();
            this.bindEvents();
            this.showStartScreen();
        }

        private initializeScores(): void {
            Object.keys(cutletResults).forEach(key => {
                this.scores[key] = 0;
            });
        }

        private bindEvents(): void {
            const startButton = document.getElementById('startButtonMatcher');
            const restartButton = document.getElementById('restartButtonMatcher');
            const swipeLeftBtn = document.getElementById('swipeLeftBtnMatcher');
            const swipeRightBtn = document.getElementById('swipeRightBtnMatcher');

            if (startButton) {
                startButton.addEventListener('click', () => this.startGame());
            }

            if (restartButton) {
                restartButton.addEventListener('click', () => this.restartGame());
            }

            if (swipeLeftBtn) {
                swipeLeftBtn.addEventListener('click', () => this.handleSwipe(false));
            }

            if (swipeRightBtn) {
                swipeRightBtn.addEventListener('click', () => this.handleSwipe(true));
            }
        }

        private showStartScreen(): void {
            const startScreen = document.getElementById('startScreenMatcher');
            const progressBar = document.getElementById('progressBarMatcher');
            const swipeButtons = document.getElementById('swipeButtonsMatcher');

            if (startScreen) startScreen.classList.remove('hidden');
            if (progressBar) progressBar.classList.add('hidden');
            if (swipeButtons) swipeButtons.classList.add('hidden');
        }

        private selectRandomQuestions(): void {
            const shuffled = [...allQuestions].sort(() => Math.random() - 0.5);
            questions = shuffled.slice(0, 10);
        }

        private startGame(): void {
            const startScreen = document.getElementById('startScreenMatcher');
            const progressBar = document.getElementById('progressBarMatcher');
            const swipeButtons = document.getElementById('swipeButtonsMatcher');
            const questionCounter = document.getElementById('questionCounterMatcher');

            if (startScreen) startScreen.classList.add('hidden');
            if (progressBar) progressBar.classList.remove('hidden');
            if (swipeButtons) swipeButtons.classList.remove('hidden');
            if (questionCounter) questionCounter.classList.remove('hidden');

            this.currentQuestion = 0;
            this.answers = [];
            this.initializeScores();
            this.selectRandomQuestions();
            this.showQuestion();
        }

        private showQuestion(): void {
            const container = document.getElementById('cardContainer');
            if (!container) return;

            const question = questions[this.currentQuestion];

            const card = document.createElement('div');
            card.className = 'card-matcher';
            card.innerHTML = `
                <div class="card-question-box">
                    <div class="card-emoji">${question.emoji}</div>
                    <div class="card-question">${question.text}</div>
                </div>
            `;

            // Update question counter
            const questionCounter = document.getElementById('questionCounterMatcher');
            if (questionCounter) {
                questionCounter.textContent = `Fr√•ga ${this.currentQuestion + 1} av ${questions.length}`;
            }

            card.addEventListener('mousedown', (e) => this.onDragStart(e));
            card.addEventListener('touchstart', (e) => this.onDragStart(e));
            card.addEventListener('mousemove', (e) => this.onDragMove(e));
            card.addEventListener('touchmove', (e) => this.onDragMove(e));
            card.addEventListener('mouseup', (e) => this.onDragEnd(e));
            card.addEventListener('touchend', (e) => this.onDragEnd(e));
            card.addEventListener('mouseleave', (e) => this.onDragEnd(e));

            container.innerHTML = '';
            container.appendChild(card);
            this.currentCard = card;

            setTimeout(() => card.classList.add('visible'), 10);

            this.updateProgress();
        }

        private onDragStart(e: MouseEvent | TouchEvent): void {
            this.isDragging = true;
            this.startX = e instanceof MouseEvent ? e.clientX : e.touches[0].clientX;
            if (this.currentCard) {
                this.currentCard.style.transition = 'none';
            }
        }

        private onDragMove(e: MouseEvent | TouchEvent): void {
            if (!this.isDragging || !this.currentCard) return;

            const clientX = e instanceof MouseEvent ? e.clientX : e.touches[0].clientX;
            this.currentX = clientX - this.startX;

            const rotation = this.currentX / 20;
            const opacity = Math.max(0.5, 1 - Math.abs(this.currentX) / 300);

            this.currentCard.style.transform = `translateX(${this.currentX}px) rotate(${rotation}deg)`;
            this.currentCard.style.opacity = opacity.toString();

            if (this.currentX > 50) {
                this.currentCard.classList.add('swipe-right-hint');
                this.currentCard.classList.remove('swipe-left-hint');
            } else if (this.currentX < -50) {
                this.currentCard.classList.add('swipe-left-hint');
                this.currentCard.classList.remove('swipe-right-hint');
            } else {
                this.currentCard.classList.remove('swipe-right-hint', 'swipe-left-hint');
            }
        }

        private onDragEnd(e: MouseEvent | TouchEvent): void {
            if (!this.isDragging || !this.currentCard) return;

            this.isDragging = false;

            if (Math.abs(this.currentX) > 100) {
                const isYes = this.currentX > 0;
                this.animateSwipeOut(isYes);
            } else {
                this.currentCard.style.transition = 'all 0.3s ease';
                this.currentCard.style.transform = 'translateX(0) rotate(0)';
                this.currentCard.style.opacity = '1';
                this.currentCard.classList.remove('swipe-right-hint', 'swipe-left-hint');
            }

            this.currentX = 0;
        }

        private animateSwipeOut(isYes: boolean): void {
            if (!this.currentCard) return;

            const direction = isYes ? 1 : -1;
            this.currentCard.style.transition = 'all 0.3s ease';
            this.currentCard.style.transform = `translateX(${direction * 500}px) rotate(${direction * 30}deg)`;
            this.currentCard.style.opacity = '0';

            setTimeout(() => {
                this.handleSwipe(isYes);
            }, 300);
        }

        private handleSwipe(answer: boolean): void {
            const question = questions[this.currentQuestion];
            this.answers.push(answer);

            const points = answer ? question.yesPoints : question.noPoints;
            Object.keys(points).forEach(key => {
                if (this.scores[key] !== undefined) {
                    this.scores[key] += points[key];
                }
            });

            this.currentQuestion++;

            if (this.currentQuestion < questions.length) {
                setTimeout(() => this.showQuestion(), 300);
            } else {
                setTimeout(() => this.showResult(), 500);
            }
        }

        private updateProgress(): void {
            const progressFill = document.getElementById('progressFillMatcher');
            const progressText = document.getElementById('progressTextMatcher');

            const percentage = (this.currentQuestion / questions.length) * 100;

            if (progressFill) {
                progressFill.style.width = `${percentage}%`;
            }

            if (progressText) {
                progressText.textContent = `${this.currentQuestion}/${questions.length}`;
            }
        }

        private showResult(): void {
            let maxScore = -1;
            let winningCutlet = 'classic';

            Object.keys(this.scores).forEach(key => {
                if (this.scores[key] > maxScore) {
                    maxScore = this.scores[key];
                    winningCutlet = key;
                }
            });

            const result = cutletResults[winningCutlet];

            const resultScreen = document.getElementById('resultScreenMatcher');
            const resultContent = document.getElementById('cutletResult');
            const progressBar = document.getElementById('progressBarMatcher');
            const swipeButtons = document.getElementById('swipeButtonsMatcher');
            const cardContainer = document.getElementById('cardContainer');
            const questionCounter = document.getElementById('questionCounterMatcher');

            if (progressBar) progressBar.classList.add('hidden');
            if (swipeButtons) swipeButtons.classList.add('hidden');
            if (cardContainer) cardContainer.innerHTML = '';
            if (questionCounter) questionCounter.classList.add('hidden');

            if (resultContent) {
                resultContent.innerHTML = `
                    <div class="result-emoji">${result.emoji}</div>
                    <h3 class="result-name">${result.name}</h3>
                    <p class="result-description">${result.description}</p>
                    <div class="result-characteristics">
                        <h4>K√§nnetecken:</h4>
                        <div class="characteristics-grid">
                            ${result.characteristics.map(char => `<div class="characteristic-item">${char}</div>`).join('')}
                        </div>
                        ${result.recipe ? `<div class="result-actions"><a href="${result.recipe}" class="recipe-btn">Se recept ‚Üí</a></div>` : ''}
                    </div>
                `;
            }

            if (resultScreen) {
                resultScreen.classList.remove('hidden');
            }
        }

        private restartGame(): void {
            const resultScreen = document.getElementById('resultScreenMatcher');
            if (resultScreen) resultScreen.classList.add('hidden');

            this.startGame();
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        new MeatMatchGame();
    });
</script>

<style>
    .container {
        max-width: 1000px;
    }

    .subtitle {
        text-align: center;
        font-size: 1.3rem;
        margin-bottom: 3rem;
        color: #5d3a1a;
        border-bottom: 2px solid #8b5a2b;
        padding-bottom: 1.5rem;
    }

    .game-wrapper {
        background: rgba(139, 90, 43, 0.08);
        padding: 2rem;
        border: 3px solid #8b5a2b;
        border-radius: 8px;
    }

    .game-ui {
        margin-bottom: 1.5rem;
    }

    .ui-top {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr 1fr;
        gap: 1rem;
        margin-bottom: 1rem;
    }

    .ui-item {
        background: rgba(139, 46, 11, 0.1);
        padding: 1rem;
        border-radius: 6px;
        border: 2px solid #8b5a2b;
        text-align: center;
    }

    .ui-label {
        display: block;
        font-family: 'Bebas Neue', sans-serif;
        font-size: 1rem;
        color: #8b2e0b;
        letter-spacing: 1px;
        text-transform: uppercase;
        margin-bottom: 0.25rem;
    }

    .ui-value {
        display: block;
        font-family: 'Bebas Neue', sans-serif;
        font-size: 2rem;
        color: #8b5a2b;
        font-weight: 700;
        line-height: 1;
    }

    .combo-display {
        position: relative;
        transition: all 0.3s;
    }

    .combo-display.active {
        background: rgba(255, 215, 0, 0.2);
        border-color: #ffd700;
        transform: scale(1.05);
    }

    .combo-value {
        color: #8b5a2b;
    }

    .combo-display.active .combo-value {
        color: #d4a000;
    }

    .game-container {
        position: relative;
        background: #2a2a2a;
        border: 4px solid #8b5a2b;
        border-radius: 8px;
        overflow: hidden;
        margin-bottom: 1.5rem;
    }

    #gameCanvas {
        display: block;
        margin: 0 auto;
        max-width: 100%;
        height: auto;
    }

    .game-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.85);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
    }

    .game-overlay.hidden {
        display: none;
    }

    .overlay-content {
        text-align: center;
        color: #f5f1e8;
        padding: 2rem;
    }

    .overlay-content h2 {
        font-family: 'Bebas Neue', sans-serif;
        font-size: 3rem;
        color: #ffd700;
        margin-bottom: 1rem;
        letter-spacing: 3px;
        text-transform: uppercase;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }

    .overlay-content p {
        font-size: 1.3rem;
        margin-bottom: 2rem;
        color: #f5f1e8;
    }

    .final-stats {
        background: rgba(139, 90, 43, 0.2);
        padding: 1.5rem;
        border-radius: 8px;
        margin-bottom: 2rem;
        border: 2px solid #8b5a2b;
    }

    .final-stats.hidden {
        display: none;
    }

    .level-complete-stats {
        background: rgba(255, 215, 0, 0.2);
        padding: 1.5rem;
        border-radius: 8px;
        margin-bottom: 2rem;
        border: 2px solid #ffd700;
    }

    .level-complete-stats.hidden {
        display: none;
    }

    .stat-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 1rem;
        font-size: 1.2rem;
    }

    .stat-item:last-child {
        margin-bottom: 0;
    }

    .stat-label {
        color: #d4a574;
        font-weight: 600;
    }

    .stat-value {
        color: #ffd700;
        font-family: 'Bebas Neue', sans-serif;
        font-size: 1.5rem;
        font-weight: 700;
    }

    .game-button {
        padding: 1rem 3rem;
        background: #8b2e0b;
        color: #f5f1e8;
        border: 3px solid #5d1f08;
        border-radius: 6px;
        font-family: 'Bebas Neue', sans-serif;
        font-size: 1.5rem;
        cursor: pointer;
        transition: all 0.2s;
        text-transform: uppercase;
        letter-spacing: 2px;
    }

    .game-button:hover {
        background: #a83b14;
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
    }

    .game-button:active {
        transform: translateY(0);
    }

    .secondary-button {
        background: #d4a000;
        border-color: #a67c00;
        margin-top: 1rem;
    }

    .secondary-button:hover {
        background: #ffd700;
    }

    .secondary-button.hidden {
        display: none;
    }

    .game-info {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        margin-bottom: 2rem;
    }

    .info-item {
        background: #fffef9;
        padding: 0.75rem 1rem;
        border: 2px solid #8b5a2b;
        border-radius: 6px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .info-label {
        color: #5d3a1a;
        font-weight: 600;
    }

    .info-value {
        font-family: 'Bebas Neue', sans-serif;
        font-size: 1.5rem;
        color: #8b2e0b;
        font-weight: 700;
    }

    .instructions {
        background: #fffef9;
        padding: 1.5rem;
        border: 2px dashed #8b5a2b;
        border-radius: 6px;
    }

    .instructions h3 {
        font-family: 'Bebas Neue', sans-serif;
        font-size: 1.5rem;
        color: #8b2e0b;
        margin-bottom: 1rem;
        letter-spacing: 1px;
        text-transform: uppercase;
    }

    .instructions ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    .instructions li {
        margin-bottom: 0.75rem;
        color: #5d3a1a;
        line-height: 1.6;
    }

    .instructions li:last-child {
        margin-bottom: 0;
    }

    @media (max-width: 768px) {
        .game-wrapper {
            padding: 1rem;
        }

        .ui-top {
            grid-template-columns: 1fr;
            gap: 0.75rem;
        }

        .ui-item {
            padding: 0.75rem;
        }

        .ui-label {
            font-size: 0.9rem;
        }

        .ui-value {
            font-size: 1.5rem;
        }

        .game-info {
            grid-template-columns: 1fr;
        }

        .overlay-content h2 {
            font-size: 2rem;
        }

        .overlay-content p {
            font-size: 1.1rem;
        }

        .game-button {
            font-size: 1.2rem;
            padding: 0.9rem 2rem;
        }

        .instructions {
            padding: 1rem;
        }

        .instructions h3 {
            font-size: 1.3rem;
        }

        .instructions li {
            font-size: 0.95rem;
        }
    }

    /* Meat Matcher Styles */
    .game-wrapper-matcher {
        background: linear-gradient(135deg, rgba(255, 182, 193, 0.15), rgba(255, 218, 185, 0.15));
        padding: 2rem;
        border: 3px solid #8b5a2b;
        border-radius: 16px;
        min-height: 600px;
        position: relative;
        max-width: 600px;
        margin: 0 auto;
    }

    .question-counter-matcher {
        text-align: center;
        font-family: 'Bebas Neue', sans-serif;
        font-size: 1.5rem;
        color: #5d3a1a;
        font-weight: 700;
        margin-bottom: 1.5rem;
        text-transform: uppercase;
        letter-spacing: 2px;
    }

    .question-counter-matcher.hidden {
        display: none;
    }

    .card-container {
        width: 100%;
        height: 450px;
        position: relative;
        margin-bottom: 2rem;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .card-matcher {
        position: absolute;
        width: 100%;
        max-width: 500px;
        height: 450px;
        background: transparent;
        border-radius: 0;
        box-shadow: none;
        padding: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        cursor: grab;
        user-select: none;
        opacity: 0;
        transform: scale(0.9);
        transition: all 0.3s ease;
    }

    .card-matcher.visible {
        opacity: 1;
        transform: scale(1);
    }

    .card-matcher:active {
        cursor: grabbing;
    }

    .card-matcher .card-question-box {
        width: 100%;
        background: white;
        border: 4px solid #8b5a2b;
        border-radius: 24px;
        padding: 3rem 2.5rem;
        box-shadow: 0 8px 30px rgba(139, 90, 43, 0.4);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 2rem;
    }

    .card-matcher .card-emoji {
        font-size: 10rem;
        margin: 0;
        line-height: 1;
    }

    .card-matcher .card-question {
        font-size: 2.4rem;
        color: #5d3a1a;
        font-weight: 700;
        line-height: 1.4;
        margin: 0;
    }

    .card-matcher.swipe-right-hint::after {
        content: "‚ô• JA";
        position: absolute;
        top: 50px;
        right: 50px;
        font-size: 3rem;
        color: #4caf50;
        font-weight: bold;
        opacity: 0.7;
        transform: rotate(20deg);
    }

    .card-matcher.swipe-left-hint::after {
        content: "‚úï NEJ";
        position: absolute;
        top: 50px;
        left: 50px;
        font-size: 3rem;
        color: #f44336;
        font-weight: bold;
        opacity: 0.7;
        transform: rotate(-20deg);
    }

    .progress-bar-matcher {
        width: 100%;
        height: 40px;
        background: rgba(255, 255, 255, 0.5);
        border-radius: 20px;
        margin-bottom: 2rem;
        position: relative;
        overflow: hidden;
        border: 2px solid #8b5a2b;
    }

    .progress-bar-matcher.hidden {
        display: none;
    }

    .progress-bar-matcher .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #ff6b9d, #ffa06b);
        border-radius: 20px;
        width: 0;
        transition: width 0.3s ease;
    }

    .progress-bar-matcher .progress-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-family: 'Bebas Neue', sans-serif;
        font-size: 1.2rem;
        color: #5d3a1a;
        font-weight: 700;
    }

    .start-screen,
    .result-screen {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, rgba(255, 182, 193, 0.3), rgba(255, 218, 185, 0.3));
        border-radius: 16px;
        z-index: 10;
    }

    .start-screen.hidden,
    .result-screen.hidden {
        display: none;
    }

    .start-content,
    .result-content {
        text-align: center;
        padding: 2rem;
        max-width: 500px;
    }

    .start-content h2,
    .result-content h2 {
        font-family: 'Bebas Neue', sans-serif;
        font-size: 2.5rem;
        color: #8b2e0b;
        margin-bottom: 1.5rem;
        letter-spacing: 2px;
    }

    .start-content p {
        font-size: 1.2rem;
        color: #5d3a1a;
        margin-bottom: 1rem;
        line-height: 1.6;
    }

    .start-button,
    .restart-button {
        margin-top: 2rem;
        padding: 1rem 3rem;
        background: linear-gradient(135deg, #ff6b9d, #ffa06b);
        color: white;
        border: none;
        border-radius: 50px;
        font-family: 'Bebas Neue', sans-serif;
        font-size: 1.5rem;
        cursor: pointer;
        transition: all 0.3s;
        text-transform: uppercase;
        letter-spacing: 2px;
        box-shadow: 0 5px 20px rgba(255, 107, 157, 0.4);
    }

    .start-button:hover,
    .restart-button:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(255, 107, 157, 0.6);
    }

    .swipe-buttons {
        display: flex;
        gap: 2rem;
        justify-content: center;
        margin-top: 2rem;
    }

    .swipe-buttons.hidden {
        display: none;
    }

    .swipe-btn {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        border: 3px solid;
        background: white;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        font-family: 'Bebas Neue', sans-serif;
    }

    .swipe-btn:hover {
        transform: scale(1.1);
    }

    .swipe-btn:active {
        transform: scale(0.95);
    }

    .swipe-left {
        border-color: #f44336;
        color: #f44336;
    }

    .swipe-left:hover {
        background: #f44336;
        color: white;
    }

    .swipe-right {
        border-color: #4caf50;
        color: #4caf50;
    }

    .swipe-right:hover {
        background: #4caf50;
        color: white;
    }

    .btn-icon {
        font-size: 2rem;
        line-height: 1;
    }

    .btn-text {
        font-size: 0.8rem;
        margin-top: 0.2rem;
    }

    .cutlet-result {
        background: #f5f1e8;
        padding: 0;
        border: 6px solid #8b2e0b;
        border-radius: 0;
        box-shadow:
            12px 12px 0 rgba(139, 46, 11, 0.3),
            0 0 0 2px #5d3a1a;
        position: relative;
    }

    .cutlet-result::before {
        content: '';
        position: absolute;
        top: -3px;
        left: -3px;
        right: -3px;
        bottom: -3px;
        background: repeating-linear-gradient(
            45deg,
            transparent,
            transparent 10px,
            rgba(139, 46, 11, 0.1) 10px,
            rgba(139, 46, 11, 0.1) 20px
        );
        z-index: -1;
        pointer-events: none;
    }

    .result-emoji {
        font-size: 8rem;
        margin: 0;
        padding: 2rem 0 1rem 0;
        background: #8b2e0b;
        border-bottom: 6px solid #5d1f08;
        text-align: center;
        line-height: 1;
        filter: drop-shadow(3px 3px 0 rgba(0, 0, 0, 0.2));
    }

    .result-name {
        font-family: 'Bebas Neue', sans-serif;
        font-size: 2.5rem;
        color: #f5f1e8;
        background: #5d3a1a;
        margin: 0;
        padding: 1.5rem 2rem;
        letter-spacing: 3px;
        text-transform: uppercase;
        text-align: center;
        border-bottom: 4px solid #2a1810;
        text-shadow: 3px 3px 0 rgba(0, 0, 0, 0.3);
    }

    .result-description {
        font-size: 1.3rem;
        color: #5d3a1a;
        margin: 0;
        padding: 2rem;
        line-height: 1.6;
        background: rgba(139, 90, 43, 0.1);
        border-bottom: 4px dashed #8b5a2b;
        font-weight: 600;
        text-align: center;
        font-style: italic;
    }

    .result-characteristics {
        text-align: left;
        margin: 0;
        padding: 2.5rem;
        background: #fffef9;
    }

    .result-characteristics h4 {
        font-family: 'Bebas Neue', sans-serif;
        font-size: 1.8rem;
        color: #8b2e0b;
        margin: 0 0 2rem 0;
        letter-spacing: 2px;
        text-transform: uppercase;
        border-left: 6px solid #8b2e0b;
        padding-left: 1rem;
        background: rgba(139, 46, 11, 0.05);
        padding-top: 0.75rem;
        padding-bottom: 0.75rem;
    }

    .characteristics-grid {
        padding: 0;
        margin: 0;
        display: grid;
        gap: 2rem;
    }

    .characteristic-item {
        padding: 2rem 3rem;
        padding-left: 5rem;
        position: relative;
        color: #2a1810;
        line-height: 2.2;
        background: white;
        border: 3px solid #8b5a2b;
        border-left: 6px solid #8b2e0b;
        font-weight: 600;
        font-size: 1.15rem;
        box-shadow: 4px 4px 0 rgba(139, 90, 43, 0.2);
        transition: all 0.2s;
    }

    .characteristic-item:hover {
        transform: translate(-2px, -2px);
        box-shadow: 6px 6px 0 rgba(139, 90, 43, 0.3);
    }

    .characteristic-item::before {
        content: "ü•©";
        position: absolute;
        left: 1.5rem;
        top: 50%;
        transform: translateY(-50%);
        font-size: 1.8rem;
    }

    .result-actions {
        margin-top: 2rem;
        padding-top: 2rem;
        border-top: 4px dashed #8b5a2b;
        text-align: center;
    }

    .result-actions .recipe-btn {
        width: 100%;
        font-size: 1.5rem;
        padding: 1.5rem 2rem;
        box-shadow: 6px 6px 0 #5d1f08;
    }

    .result-actions .recipe-btn:hover {
        transform: translate(-2px, -2px);
        box-shadow: 8px 8px 0 #5d1f08;
    }

    .result-actions .recipe-btn:active {
        transform: translate(2px, 2px);
        box-shadow: 2px 2px 0 #5d1f08;
    }

    @media (max-width: 768px) {
        .game-wrapper-matcher {
            padding: 1rem;
            min-height: 500px;
        }

        .question-counter-matcher {
            font-size: 1.2rem;
            margin-bottom: 1rem;
        }

        .card-matcher {
            height: 400px;
            max-width: 380px;
        }

        .card-container {
            height: 450px;
        }

        .card-matcher .card-question-box {
            padding: 2.5rem 2rem;
            gap: 1.5rem;
        }

        .card-matcher .card-emoji {
            font-size: 7rem;
        }

        .card-matcher .card-question {
            font-size: 1.8rem;
        }

        .cutlet-result {
            box-shadow:
                8px 8px 0 rgba(139, 46, 11, 0.3),
                0 0 0 2px #5d3a1a;
        }

        .result-emoji {
            font-size: 6rem;
            padding: 1.5rem 0 0.75rem 0;
        }

        .result-name {
            font-size: 2rem;
            padding: 1rem 1.5rem;
            letter-spacing: 2px;
        }

        .result-description {
            font-size: 1.1rem;
            padding: 1.5rem;
        }

        .result-characteristics {
            padding: 2rem 1.5rem;
        }

        .result-characteristics h4 {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .characteristics-grid {
            gap: 1.5rem;
        }

        .characteristic-item {
            padding: 1.5rem 2rem;
            padding-left: 4rem;
            font-size: 1rem;
            line-height: 2;
            box-shadow: 3px 3px 0 rgba(139, 90, 43, 0.2);
        }

        .characteristic-item:hover {
            transform: translate(-1px, -1px);
            box-shadow: 4px 4px 0 rgba(139, 90, 43, 0.3);
        }

        .characteristic-item::before {
            font-size: 1.5rem;
            left: 1.2rem;
        }

        .result-actions .recipe-btn {
            font-size: 1.3rem;
            padding: 1.2rem 1.5rem;
            box-shadow: 4px 4px 0 #5d1f08;
        }

        .result-actions .recipe-btn:hover {
            box-shadow: 5px 5px 0 #5d1f08;
        }
    }
</style>
